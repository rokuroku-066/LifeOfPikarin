# 🎯 全体コンセプトと設計方針

## 目的

* 俯瞰固定カメラで**長時間眺められる映像作品**としての箱庭シミュレーション。
* 最初は**ただのキューブ群**として実装し、その後**FBXモデル＋アニメーション**へ差し替え可能な構造。
* 個体は Alife 的に

  * 移動
  * 成長
  * 繁殖
  * 死
    を繰り返し、
    **複数のグループ（コロニー）が自然に形成される**ような創発を狙う。
* パフォーマンス上、**O(N²)の全ペア判定は禁止**。空間グリッドで近傍のみを扱う。

## 設計の基本原則

1. **View と Simulation（Model）の完全分離**

   * Simulation Core は**数値とロジックだけ**を扱い、グラフィクスやアニメーションに依存しない。
   * View は Simulation の状態を**読み取って描画するだけ**で、Sim側の状態を書き換えない。
   * FBXアニメーションの完了を待って状態遷移を止める、など**アニメ都合でSimを止めることは禁止**。

2. **固定ステップの時間離散化**

   * Simulation は固定Δt（例：1/30秒）で進む。
   * 描画フレームレートと分離（レンダリングは補間して追従）。
   * これにより長期挙動が安定＆再現性が担保しやすい。

3. **負のフィードバックを内蔵した「自己調整」**

   * 個体数は自然に

     * **全滅**
     * **無限増殖**
       に行きがちなので、
   * エネルギー消費、食料枯渇、過密ストレス、病気などを通じて
     **局所密度に応じた自然減少メカニズム**を入れておく。

4. **グリッドベースの空間認識**

   * Reynolds の Boids のように、群れ挙動は「局所近傍だけを見る」仕組みで十分に創発が出る。([red3d.com][1])
   * 空間グリッド（Spatial Hash）を用いて近傍を高速取得し、**全個体ペア探索を回避**。

5. **Utilityベースの意思決定＋シンプルFSM**

   * ゲームAIで一般的な Utility-based Agent のように、
     「複数の欲求（満腹、繁殖、危険回避…）にスコアを付けて一番高い行動を選ぶ」構造。([GeeksforGeeks][2])
   * 高レベルでは有限状態機械（FSM）で状態を明示し、視覚的に分かりやすくする。

6. **“グループができやすく、維持されやすい”舞台設計**

   * 資源パッチ、遺伝的な色タグ、巣（ネスト）やフェロモン場などを組み合わせて、
     「一つの巨大な団子」ではなく、**複数のコロニーに自然分節する**よう誘導する。

---

# 1. レイヤ構成（責務の分離）

### Layer 1: Simulation Core（世界の本体）

**責務**

* 生命・資源・環境・時間に関するすべてのロジック。

**主なコンポーネント**

* **WorldManager**

  * シミュレーション時間の管理（固定ステップ進行）。
  * 各サブシステム（環境・AI・物理・生物サイクル）を順番に呼ぶ。

* **EntityManager**

  * Agent（個体）の生成・削除。
  * Agent の配列（またはリスト）管理。
  * 死亡フラグが立った個体の後処理。

* **SpatialGrid**

  * 空間を固定サイズセルに分割し、各セルに個体IDリストを持つ。
  * 近傍検索（自セル＋隣接セルの走査）を提供。

* **EnvironmentSystem**

  * 食料パッチの生成・再生（リスポーン）。
  * 危険エリア・匂い場（フェロモンフィールド）の拡散・減衰。
  * 各セル単位での「資源量」「危険度」「居心地度」などを更新。

* **AISystem**

  * 各Agentに対し、近傍と環境から「欲求」と「行動」を決定。
  * Utility計算＋FSMによる状態遷移。

* **SteeringSystem**

  * 選択された行動に基づき、
    Seek / Wander / Separation / Alignment / Cohesion / Avoid等
    の Steering 力を合成し、目標速度・方向を決定。([red3d.com][1])

* **LifeCycleSystem**

  * エネルギー消費、成長、寿命判定。
  * 繁殖条件判定と新個体の生成。
  * 密度に応じた負のフィードバック（疫病・繁殖抑制など）を適用。

---

### Layer 2: Visualization（見た目）

**責務**

* Simulation Coreの状態を読み取り、画面に投影する。
* Simulationには**一切書き込まない**。

**主なコンポーネント**

* **AgentViewMapper**

  * AgentData → View用パラメータ
    （位置、向き、色、スケール、状態ID など）の変換。

* **CubeInstancingRenderer（フェーズ1）**

  * 大量のキューブをインスタンシングで描画。
  * 行列（位置・回転・スケール）＋色などのバッファを毎フレーム更新してGPUへ送る。
  * 数千〜数万体スケールを想定。

* **FBXViewPool（フェーズ2）**

  * ある程度少ない数（近い個体、代表個体など）をFBXモデルで表示。
  * 残りはキューブやビルボード表現に落とすLODも検討。
  * Animator には Sim側の「速度」「状態」「成長段階」などを渡すが、
    Animatorの事情でSimロジックを止めない。

---

### Layer 3: Data & Config（遺伝子と世界設定）

**責務**

* 設定値・乱数シード・遺伝情報・初期ワールド構成を一元管理。
* 実験／作品のバージョンごとにパラメータを保存して再現可能にする。

**主なデータ**

* **SimulationConfig**

  * 乱数シード
  * ワールドサイズ
  * タイムステップ
  * 初期個体数
  * 資源パッチの数・位置・再生速度

* **AgentGenetics / SpeciesConfig**

  * 平均寿命・寿命ばらつき
  * 基本移動速度・加速
  * 視野半径・視野角
  * 基本代謝量
  * グループタグ（色相）・その変異幅

* **FeedbackConfig**

  * 個体数上限、密度しきい値
  * 密度による繁殖抑制率
  * 疫病発生確率など

---

### Layer 4: Observation & Logging（観察・記録）

**責務**

* 長期観察用に、シミュレーションのメタ情報を記録。
* 映像と紐づくデータログとして活用。

**主な要素**

* 総個体数・世代数・平均寿命・死亡原因の比率などの統計。
* グループ（群れ）ごとの個体数推移。
* 誕生/死/巣の形成などのイベントログ。

Amorphous Fortress のようなオープンエンドなマルチエージェント環境でも、
世界構成とログが明示されていると観察・再利用がしやすい。([Game Engineering][3])

---

# 2. データ設計（Simulation側）

## 2-1. AgentData（個体）

**識別**

* ID
* 世代（0, 1, 2, …）
* グループID（群れの所属。可視化にも使用）

**位置・運動**

* 位置ベクトル（論理的には2D平面、ViewではYを高さで使っても良い）
* 速度ベクトル
* 現在の向き（heading）
* Steering の一時的な合成結果（目標速度/方向）

**生理・ライフサイクル**

* 年齢
* 最大寿命（遺伝で決まる）
* エネルギー（0で死亡）
* サイズ（成長度合い：子ども→大人→老い）

**内部状態（行動状態・時間）**

* 現在の状態（Idle / Wander / Forage / Eat / SeekMate / Mate / Rest / Flee / Dead など）
* 状態にとどまっている時間（ヒステリシス用）

**欲求・ドライブ（Utility計算用）**

* 食欲（空腹レベル）
* 繁殖欲求
* 社会的欲求（他個体への近接を求める度合い）
* 休息欲求
* 探索欲求（同じ場所に長くいると増加） など

**遺伝子・特性（Traits）**

* 基本移動速度係数
* 視野半径・視野角
* 代謝率（エネルギー消費スピード）
* グループタグ（例：色相値 0〜1）
* グループタグへの親和性（自分と近いタグをどれだけ好むか）

Guideless ALife モデルのように、事前の適応度関数を決めず、
「局所的ルールと突然変異」の結果として系統が残ったり消えたりする構造を意識する。([MIT Press Direct][4])

---

## 2-2. SpatialGrid（空間インデックス）

**構造**

* ワールドを固定セル（例：2m×2m）に区切る。
* 各セルは「そこにいるAgentのインデックスのリスト」を持つ。

**運用**

* 各Simulationステップごとに、全Agentの位置からセルを計算し、Gridに再登録。
* 実装を簡単にするなら「毎フレーム全セルをクリア→全Agentを登録」方式でも、数千体規模なら現代環境で十分高速。

**近傍検索**

* Agentが近傍を調べるときは

  * 自セル
  * 周囲8セル
    だけを見る。
* この設計により、計算量は概ね O(N × 近傍数) に落ちる。

---

## 2-3. Environment（環境）

* **資源パッチ**

  * 位置・半径
  * 現在の資源量
  * 最大資源量
  * 再生速度（時間あたりの回復）

* **危険エリア**

  * 位置・範囲
  * ダメージ量（時間あたり）

* **場（Field）**

  * グリッドセル単位のスカラー/ベクトル場

    * 食料密度
    * 巣フェロモン濃度（グループIDごと）
    * 危険度（火事・毒など）

---

# 3. 更新ループ（Simulationステップ）

固定Δtごとに以下の順序で処理：

1. **Grid更新**

   * 全Agentの位置からセルを再計算し、SpatialGridを構築。

2. **環境更新（EnvironmentStep）**

   * 資源パッチの回復・枯渇処理。
   * フェロモンや巣の“匂い場”の拡散・減衰。
   * 災害イベントを入れるならここで実行（季節変化・天候など）。

3. **感覚（Perception）**

   * 各AgentがSpatialGridを使って近傍Agent/資源を取得。
   * 近傍セルの統計（個体数、平均向き、平均色タグなど）も取得。

4. **意思決定（Decision / AI）**

   * 内部状態（エネルギー、年齢、欲求ドライブ）と近傍情報を元に
     行動候補ごとのUtility（満足度）を計算。([GeeksforGeeks][2])
   * もっともスコアの高い行動に対応するFSM状態へ遷移。
   * 状態遷移にはヒステリシス（粘り）とクールダウンを設定して「迷い行動」を防止。

5. **Steering計算**

   * 状態ごとの目的に応じて、以下の Steering を合成：

     * Separation（近すぎる個体から離れる）
     * Alignment（近傍と進行方向を合わせる）
     * Cohesion（近傍の中心へ向かう）
     * Seek（食料/巣/交配相手などのターゲットへ向かう）
     * Wander（ランダムな揺らぎで自然さを出す）
     * ObstacleAvoid / BoundaryForce（壁や外周から離れる）
   * Reynolds の Steering Behaviors 同様、複数の単純なベクトルを重み付きで足し合わせるシンプルなモデル。([red3d.com][1])

6. **運動更新（Integration）**

   * Steering結果から速度を更新し、速度を上限で制限。
   * 位置を更新し、ワールド外に出ないよう補正。
   * 簡易的な押し出し（重なり解消）は Separation の強さで吸収する設計でもよい。

7. **生物学的更新（LifeCycle）**

   * 時間経過による年齢＋成長段階の更新。
   * 移動距離などに応じたエネルギー消費。
   * エネルギー0以下や寿命超過で死亡フラグを立てる。

8. **繁殖＆死亡処理**

   * 繁殖条件を満たすペアを、近傍内から選択。
   * 新個体を生成し、親の遺伝子＋小ランダム変異でTraitsを決定。
   * 死亡フラグの立った個体を削除し、
     その位置にわずかな資源（食料）を還元するなどの循環を入れる。

9. **負のフィードバック適用**

   * グローバルな総個体数と、セルごとの局所密度を評価。
   * 密度が高すぎるセルでは：

     * エネルギー消費増加
     * 繁殖成功率低下
     * 疫病（ランダム死亡確率）の発生 などを適用し、
       **過密状態を自然に解消する方向**へ押す。

10. **統計・ログ更新**

    * 個体数、群れの数、平均寿命、死亡原因分布などを収集。
    * アート作品として重要な期間を検出・記録するためのメタデータとして保存。

---

# 4. 行動決定と群れ形成の仕掛け

## 4-1. Utility＋FSMによる行動決定

**候補行動の例**

* 食事（Forage / Eat）
* 探索（Wander）
* 群れ行動（Flock）
* 繁殖（SeekMate / Mate）
* 休息（Rest）
* 危険回避（Flee）

**Utility計算の基本**

* 行動ごとに、「対応する欲求ドライブ」＋「環境条件」からスコアを計算。
* 例）

  * 食事：空腹度が高く、近くに資源があるときスコア上昇。
  * 繁殖：エネルギーが十分で、近くに相性の良い相手がいるときスコア上昇。
  * 休息：エネルギーはあるが、活動時間が長く疲労しているときスコア上昇。

**FSMとの関係**

* Utilityで「次にやりたい行動」を決める。
* FSMは「今の状態が何で、いつ終えるか」を管理：

  * 例：食事状態に入ったら、一定時間or満腹になるまで続ける。
* これにより、Amorphous Fortress のようなFSMベースの多エージェント系で見られる
  **“行動のまとまり”と“創発”**を維持しつつ、Utilityで柔軟性を持たせる。([arXiv][5])

---

## 4-2. 複数グループができるための要素

1. **資源パッチの分布**

   * マップに複数の資源パッチを配置（例：3〜7箇所）。
   * それぞれ再生速度や安全度を微妙に変える。
   * 群れは自然にそれぞれのパッチ周辺に定住しやすくなる。

2. **グループタグ（色相）と遺伝的親和性**

   * 各個体は `グループタグ（色相値）` を持ち、それが見た目の色にも反映される。
   * Steering の Cohesion / Alignment の強さを、タグ類似度に応じて変化させる：

     * 似たタグには Cohesion を強く
     * 異なるタグには Separation をやや強く
   * 子どもは親のタグを継承しつつ、小さな変異を加える。
     → これにより、**色ごとの群れ・血統**が自然に分岐しやすくなる。

3. **巣（Nest）とフェロモン場**

   * 繁殖が成功した地点に「巣」を形成し、その周囲にフェロモン場を発生させる。
   * フェロモン場は時間とともに減衰するが、同グループタグの個体はそこを「居心地が良い」と感じて戻りやすくなる。
   * 結果として、**グループごとの“コロニー中心地”ができる**。

4. **過密抑制による分散**

   * 一つの資源パッチや巣周辺が過密になると、そこにいる個体の

     * エネルギー消費増加
     * 繁殖成功率低下
       などのペナルティをかける。
   * これにより一部は他の資源パッチへ移住し、世界全体で**複数のコロニーが共存**しやすくなる。

---

# 5. View設計：キューブ → FBXへのスムーズな移行

## 5-1. Phase 1：キューブ表現

**目的**

* システム全体のロジック・パラメータ・創発パターンの検証を
  高パフォーマンスで行うフェーズ。

**表現ルールの例**

* 位置・向き：AgentData の position / heading をそのまま反映。
* 色相：グループタグ（血統）を直接色にマッピング。
* 明度・輝度：エネルギー量を反映（弱ると暗くなるなど）。
* スケール：

  * 子ども：小さい
  * 大人：標準サイズ
  * 老い：やや縮む or 揺らぎが増す
* 発光やパルス：

  * 繁殖可能状態（repro欲求が高いとき）に淡い点滅を入れる。

これだけで、上から見たときに

* 「どこにどんな血統の群れがいるか」
* 「どこが若いコロニーで、どこが老いているか」
* 「繁殖が活発なゾーンはどこか」

が**一目で分かる絵**になる。

## 5-2. Phase 2：FBX／アニメーション

**基本方針**

* Simulation側には一切手を入れず、View層の差し替えのみで実現。
* 個々のFBXは “代表的な個体” や “カメラに近い個体” に限定し、
  遠景は引き続きキューブや簡易モデルで表現（LOD）。

**Viewが受け取る情報**

* 位置・向き
* 移動速度（AnimatorのSpeedに反映）
* 行動状態（Idle / Walk / Eat / Mate / Sleep など）
* 成長段階（Child / Adult / Old）

**Animatorとの関係**

* Animationの遷移は、Sim側の状態IDをパラメータとして受け取るのみ。
* 「アニメが終わるまで状態遷移しない」「アニメーションイベントでロジックを制御」などは行わない（あくまで片方向）。

---

# 6. 長期観察用の安定性とリスク管理

## 6-1. 安定運用のためのフィードバック

* **個体数管理**

  * グローバルな最大個体数キャップ。
  * キャップ近辺では繁殖成功率を自動で下げる。

* **局所密度管理**

  * SpatialGridでセルごとに個体数をカウント。
  * しきい値超えセルでは

    * エネルギー消費増加
    * 疫病の確率的発生
      などで自然に密度を下げる。

* **資源ダイナミクス**

  * 一度食べ尽くした資源パッチはしばらく枯渇し、その間は他パッチに移動せざるを得ない。
  * 長期的には、季節変化やランダムイベントで資源配置をわずかに揺らすことで、
    コロニーが固定しすぎないようにする。

## 6-2. 想定リスクと設計上の対策（要約）

* 個体数爆発 → 負のフィードバック＋個体数キャップ。
* 全員が同じ場所に団子状態 → 資源枯渇・タグ斥力・巣の複数配置。
* 行動がガチャガチャして読めない → Utility＋FSM＋ヒステリシスで「まとまり」を作る。
* FBX化でパフォーマンスが崩壊 → LODと部分的なFBX表示に留める／キューブを基本にする。



[1]: https://www.red3d.com/cwr/steer/gdc99/?utm_source=chatgpt.com "Steering Behaviors For Autonomous Characters - red3d.com"
[2]: https://www.geeksforgeeks.org/artificial-intelligence/utility-based-agents-in-ai/?utm_source=chatgpt.com "Utility-Based Agents in AI"
[3]: https://game.engineering.nyu.edu/research/amorphous-fortress/?utm_source=chatgpt.com "Amorphous Fortress - Game Innovation Lab"
[4]: https://direct.mit.edu/artl/article/31/1/31/127798/Guideless-Artificial-Life-Model-for-Reproduction?utm_source=chatgpt.com "Guideless Artificial Life Model for Reproduction ..."
[5]: https://arxiv.org/html/2306.13169?utm_source=chatgpt.com "Observing Emergent Behavior in Multi-Agent FSMs"
